/*   
 * Copyright (c) 2011, Daniel Swann <hs@dswann.co.uk>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the owner nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define P_DIR_IN 1
#define P_DIR_OUT 2
#define P_DIR_INOUT 3

#define P_TYPE_INT 1
#define P_TYPE_VARCHAR 2

struct param 
{
  int  p_direction;
  char p_name[66];
  int  p_type;
  int  p_len;
  struct param *next_param;
};

int add_param(struct param  **param_list, char *param_line);
int seek_to(FILE *fp, char *search_str, int case_sensitive);
int generate_sp_function(char *sp_name, struct param *param_list, FILE *out_imp);
int generate_sp_header(char *sp_name, struct param *param_list, FILE *out_hed);
int read_file(char *filename,FILE *out_imp, FILE *out_hed);
int output_func_def(char *sp_name, struct param *param_list, FILE *out, int header);

int main(int argc, char *argv[])
{
  int n;
  FILE *out_imp;      // Implementation - output .cpp file
  FILE *out_hed;      // Header - output .h file
  FILE *in_imp_tpl;   // Implementation template
  FILE *in_hed_tpl;   // Header template
  char filepath [256];
  int path_end;

  char buf[512];
  char buf2[512];
  
  if (argc <= 2)
  {
    printf ("Usage:\n\t%s <base dir> <sp_one.sql> <sp_two.sql>....\n", argv[0]);
    return -1;
  }
  
  strcpy(filepath, argv[1]);
  path_end = strlen(filepath);
  strcpy(filepath+path_end, "/CNHDBAccess.cpp");
  out_imp = fopen(filepath, "w");
  if (out_imp == NULL)
  {
    printf("Failed to open [%s] for writing\n", filepath);
    return -1;
  }
  
  strcpy(filepath+path_end, "/CNHDBAccess.h");
  out_hed = fopen(filepath, "w");
  if (out_hed == NULL)
  {
    printf("Failed to open [%s] for writing\n", filepath);
    return -1;
  }
  
  fprintf(out_imp," /********************************************/ \n");
  fprintf(out_imp," /***** Auto-generated file DO NOT EDIT! *****/ \n");
  fprintf(out_imp," /********************************************/ \n\n\n");
  fprintf(out_hed," /********************************************/ \n");
  fprintf(out_hed," /***** Auto-generated file DO NOT EDIT! *****/ \n");
  fprintf(out_hed," /********************************************/ \n\n\n");  
  
  strcpy(filepath+path_end, "/CNHDBAccess_template.cpp");
  in_imp_tpl = fopen(filepath, "r");
  if (in_imp_tpl == NULL)
  {
    puts("Failed to open CNHDBAccess_template.cpp for reading");
    return -1;
  }
  
  strcpy(filepath+path_end, "/CNHDBAccess_template.h");
  in_hed_tpl = fopen(filepath, "r");
  if (in_hed_tpl == NULL)
  {
    puts("Failed to open CNHDBAccess_template.h for reading");
    return -1;
  }
  
  //copy contents of CNHDBAccess_template.cpp to CNHDBAccess.cpp until "// {AUTOGENERATED-SP-CALLS}" reached
  while (fgets(buf, sizeof(buf), in_imp_tpl)!=NULL)
  {
    if (!strcmp(buf, "// {AUTOGENERATED-SP-CALLS}\n"))
    {
      while (fgets(buf2, sizeof(buf), in_hed_tpl)!=NULL) 
      {
        if (!strcmp(buf2, "// {AUTOGENERATED-SP-DEFINITIONS}\n"))
        {
          for (n=2; n < argc; n++)
            read_file(argv[n], out_imp, out_hed);
        } else
          fputs(buf2, out_hed);
      }
    } else
      fputs(buf, out_imp);
  }
  fclose(in_imp_tpl);
  fclose(out_imp);
 
  
  return 0;
}

int read_file(char *filename, FILE *out_imp, FILE *out_hed)
{
  FILE *fp;
  char x;
  char sp_name[66]; // Maximum length of an SP name in MySQL is 65 characters
  int n;
  char param_line[256];
  int end_of_param_line;
  int end_of_params;
  int paren;
  struct param *param_list;
 // struct param *lst;
  
  char create_proc_str[] = "CREATE PROCEDURE ";
  
  param_list = NULL;
  
  fp = fopen(filename, "rb");
  if (fp==NULL)
  {
    printf("Failed to open [%s]\n", filename);
    return -1;
  }
  printf("Processing [%s]\n", filename);
  
  if (seek_to (fp, create_proc_str, 0))
    return -1;
  
  // Now read up until the next '(' (or 65 chars, whichever comes first), 
  // and store the result as the sp name
  n=0;
  memset(sp_name, 0, sizeof(sp_name));
  while ((fread(&x, 1, 1, fp) > 0) && (n < 65)) // one char at a time
  {
    if (x == '(')
      break;
    else
      if ( (x != ' ') && (x != '\n') && (x != '\r') )
        sp_name[n++] = x;
  }
  if (x != '(')
  {
    printf("Failed to find sp name!\n");
    return -1;
  }
  
  // read in parameters
  end_of_params=0;
  while (!end_of_params)
  {
    n=0;
    end_of_param_line=0;
    memset(param_line, 0, sizeof(param_line));
    paren=0;
    while ( (fread(&x, 1, 1, fp) > 0) && !end_of_param_line) // one char at a time
    {
      // Keep track of brackets used to specify variable size
      if (x == '(')  
        paren++;
      if ( (x == ')') && paren)
      {        
        paren--;      
        param_line[n++] = x;
        continue;
      }
      
      if ( (x == ',') || (!paren && (x == ')')) )
      {
        end_of_param_line = 1;
        break;
      }
      
      if ( (x == '\r') || (x == '\n')) // don't care about newlines
        continue;

      param_line[n++] = x; 
    }
    
    if ((!end_of_param_line) || (x == ')'))
      end_of_params = 1;

    if(add_param(&param_list, param_line))
    {
      //TODO: Free param list
      return -1;
    }
  }

  generate_sp_function(sp_name, param_list, out_imp);
  output_func_def(sp_name, param_list, out_hed, 1);
  
  // TODO: Free param list
  return 0;
    
}

int seek_to(FILE *fp, char *search_str, int case_sensitive)
{
  char *buf;
  int buf_len;
  int x;
  int found;
  
  found = 0;
  
  buf_len = strlen(search_str) + 1; // +1 for null terminator
  
  buf = malloc(buf_len);
  memset(buf, 0, buf_len);
  
  if (fread(buf, buf_len-1, 1, fp) <= 0)
  {
    free(buf);
    printf("Error - EOF reached searching for [%s]\n", search_str);
    return -2; // EOF;
  }
  
  if (case_sensitive)
  {
    if (!strcmp(buf, search_str))
    {
      free(buf);
      return 0;
    } else
    if (!strcasecmp(buf, search_str))
    {
      free(buf);
      return 0;
    }
  }

  while (!found)
  {
    for (x = 1; x < (buf_len-1); x++)
        buf[x-1] = buf[x];
    
    if (fread(&buf[buf_len-2], 1, 1, fp) <= 0)
    {
      free(buf);
      printf("Error - EOF reached searching for [%s]\n", search_str);
      return -2; // EOF;
    }  
    
    if (case_sensitive)
    {
      if (!strcmp(buf, search_str))
        found = 1;
    } else
    {    
      if (!strcasecmp(buf, search_str)) 
        found = 1;
    }    
  }
  
  free(buf);
  if (found)
    return 0;
  else
  {
    printf("Error - EOF reached searching for [%s]\n", search_str);
    return -2; // EOF
  }
}

int add_param(struct param **param_list, char *param_line)
{
  int line_len;
  char *ptr;
  int n;
  struct param *new_param;
  struct param *lst;
  
  int  p_type;
  int  p_dir;
  int  p_len;
  char p_len_str[32];
  char p_name[66];
  
  memset(p_name, 0, sizeof(p_name));
  memset(p_len_str, 0, sizeof(p_len_str));
  line_len = strlen(param_line);
  ptr = param_line;
  
  // Skip over any leading white space
  while ((*ptr==' ') && (ptr<(param_line+line_len)))
    ptr++;
  
  // Set direction
  if (!strncasecmp(ptr, "IN", 2))
  {
    p_dir = P_DIR_IN;    
    ptr += 3;
  }
  else if (!strncasecmp(ptr, "OUT", 3))
  {
    p_dir = P_DIR_OUT;
    ptr += 3;
  }
  else if (!strncasecmp(ptr, "INOUT", 5))
  {
    ptr += 5;
    p_dir = P_DIR_INOUT;
  }
  else
  {
    printf ("Unknown direction! (line=[%s])\n", param_line);
    return -1;
  }
  
  // Skip over any white space
  while ((*ptr==' ') && (ptr<(param_line+line_len)))
    ptr++;
  
  // Set variable name
  n=0;
  while ((*ptr != ' ') && (ptr<(param_line+line_len)))
    p_name[n++] = *ptr++;
 
  // Skip over any white space
  while ((*ptr==' ') && (ptr<(param_line+line_len)))
    ptr++;  
  
  // Set variable type
  if (!strncasecmp(ptr, "int", 3))
  {
    p_type = P_TYPE_INT;    
    ptr += 3;
  }
  else if (!strncasecmp(ptr, "varchar", 7))
  {
    p_type = P_TYPE_VARCHAR;
    ptr += 7;
  }
  else
  {
    printf ("Unknown variable type! (line=[%s])\n", param_line);
    return -1;
  }  
  
  // Get vaiable length (if present)
  if (*ptr++=='(')
  {
    n=0;
    while ((*ptr!=')') && (ptr<(param_line+line_len)))
      p_len_str[n++] = *ptr++;
    
    p_len = atoi(p_len_str);
  } else
    p_len = 0;
    
  // Now add param to list.
  new_param = malloc(sizeof(struct param));
  memset(new_param, 0, sizeof(new_param));
  new_param->p_direction = p_dir;
  memcpy(new_param->p_name, p_name, sizeof(new_param->p_name));
  new_param->p_type = p_type;
  new_param->p_len = p_len;
  new_param->next_param = NULL;
  
  // Now list yet, so this entry becomes the head
  if (*param_list == NULL)
  {
    *param_list = new_param;
    return 0;
  }
  
  // Find end of list and add new param there
  lst = *param_list;
  while (lst->next_param != NULL)
    lst = lst->next_param;
  lst->next_param = new_param;
  
  //printf("dir = %d, param_name = [%s], type = %d. len_str = %s, len = %d\n", p_dir, p_name, p_type, p_len_str, p_len);
  
  return 0;
}

int output_func_def(char *sp_name, struct param *param_list, FILE *out, int header)
{
  struct param *lst;
  int param_count;
  
  param_count = 0;
  
  // Output function definition
  if (header)
    fprintf (out, "    int %s (", sp_name);
  else
    fprintf (out, "int CNHDBAccess::%s (", sp_name);
  
  if (param_list != NULL)
  {
    lst = param_list;
    do
    {
      if (lst->p_type == P_TYPE_INT) 
        fprintf(out, "int ");
      else if ((lst->p_type == P_TYPE_VARCHAR))
        fprintf(out, "string ");
      else 
        return -1;

      if (lst->p_direction == P_DIR_IN) 
      {} //printf("");
      else if ((lst->p_direction == P_DIR_OUT))
        fprintf(out, "&");
      else if ((lst->p_direction == P_DIR_INOUT))
        fprintf(out, "&");      
      else 
        return -1;      
   
      
      if (lst->next_param == NULL)
        fprintf(out, "%s", lst->p_name);
      else
        fprintf(out, "%s, ", lst->p_name);
        
      lst = lst->next_param;
      param_count++;
    } while (lst != NULL);  
    
    if (header)
      fprintf(out, ");\n");
    else
      fprintf(out, ")\n");
  }
  
  return param_count;
}

int generate_sp_function(char *sp_name, struct param *param_list, FILE *out_imp)
{
  struct param *lst;
  int param_count;
  param_count = 0;
    
  param_count = output_func_def(sp_name, param_list, out_imp,0);
  fprintf(out_imp, "{\n");
  
  // Function body
  fprintf(out_imp, "  int param_type[%d];\n"   , param_count);  
  fprintf(out_imp, "  int param_dir[%d];\n"    , param_count);
  fprintf(out_imp, "  void *param_value[%d];\n", param_count);
  fprintf(out_imp, "  int param_len[%d];\n"    , param_count);
  fprintf(out_imp, "  int retval;\n");   
  fprintf(out_imp, "\n");
  
  param_count = 0;
  if (param_list != NULL)
  {
    lst = param_list;
    do
    {
      if (lst->p_type == P_TYPE_INT) 
        fprintf(out_imp, "  param_type[%d] =  P_TYPE_INT;\n", param_count);
      else if ((lst->p_type == P_TYPE_VARCHAR))
        fprintf(out_imp, "  param_type[%d] =  P_TYPE_VARCHAR;\n", param_count);
      else 
        return -1;

      if (lst->p_direction == P_DIR_IN) 
        fprintf(out_imp, "  param_dir[%d] = P_DIR_IN;\n", param_count);
      else if ((lst->p_direction == P_DIR_OUT))
        fprintf(out_imp, "  param_dir[%d] = P_DIR_OUT;\n", param_count);
      else if ((lst->p_direction == P_DIR_INOUT))
        fprintf(out_imp, "  param_dir[%d] = P_DIR_INOUT;\n", param_count);   
      else 
        return -1;      
   
       fprintf(out_imp, "  param_value[%d] = &%s;\n", param_count, lst->p_name);
       fprintf(out_imp, "  param_len[%d] = %d;\n", param_count, lst->p_len);
       fprintf(out_imp, "\n");
        
      lst = lst->next_param;
      param_count++;
    } while (lst != NULL);
    
    fprintf(out_imp, "  pthread_mutex_lock(&mysql_mutex);\n");
    fprintf(out_imp, "  retval = exec_sp(\"%s\", param_dir, param_type, param_value, param_len, %d);\n", sp_name, param_count);
    fprintf(out_imp, "  pthread_mutex_unlock(&mysql_mutex);\n");
    fprintf(out_imp, "  return retval;\n");
    fprintf(out_imp, "}\n\n");
  }   
  
  return 0;
}

  